///GoodHours problem///
///////////////////////

Problem Understanding and Initial Strategy:

Given the task of identifying "good" times based on the equality of the products of their digits, I recognized the need for an algorithm that can efficiently navigate through time increments. The problem requires splitting a time's digits in three potential configurations, checking each for product equality:

H and H
- The first digit and the product of the remaining three.
HH and MM - The product of the first two digits and the product of the last two.
HH
and M - The product of the first three digits and the last digit.
The strategy involved parsing the "HH
" format, iterating over the time range, and applying these checks systematically.

Development and Troubleshooting:

Initial challenges arose when handling times that span across midnight, such as from "23:00" to "01:00". 
 The basic loop structure failed to account for this, as it would prematurely terminate due to the start time being numerically greater than the end time.

Initially, the loop structure did not correctly handle cases where the afterTime was numerically
 less than the beforeTime, which is typical when the time range spans over midnight. 
 This was evident when the algorithm failed to count any "good" times in test cases like "23:00" to "01:00".

Introduced a conditional reset for the minute counter inside the nested loop. 
 This was crucial for starting the minute count from 0 on the next hour immediately
 after the first loop iteration, ensuring continuous counting through the day.

Adjusted the condition within the inner loop (if (i == finishHH && j > finishMM) break;) 
 to terminate the loop precisely when the end time is exceeded in the final hour of the range.


Insight and Reflection:

The problem-solving process revealed significant insights into handling date-time data types and their peculiarities, 
 such as day wrap-around and minute reset at each hour. The adjustment to a linear and continuous counting mechanism rather 
 than segmenting the day provided a more robust and error-resistant approach.


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///BlackAndWhiteSolitaire problem///
///////////////////////////////////

Problem Understanding and Initial Strategy///
/////////////////////////////////////////////
The BlackAndWhiteSolitaire problem involves a sequence of cards, each displayed either 'B' 
 (black) or 'W' (white). The objective is to achieve an alternating sequence where no two 
 consecutive cards are the same color, by flipping the minimum number of cards.

e.g.
For the sequence "BBBW", flipping the second 'B' results in an alternating pattern "BWBW", 
 requiring one flip.

Development and Troubleshooting///
//////////////////////////////////
Considered treating the string like a linked list for ease of traversal, 
 keeping track of the current and previous card states.

If two consecutive cards are the same, flip the current card to ensure alternation. 
 This approach was direct but lacked global optimization.

Initially, the algorithm made local decisions to flip the next card if two consecutive cards were the same. 
 However, this approach did not account for cases where flipping earlier cards might lead to fewer overall flips.

Did not initially consider the impact of the sequence's starting card on the total number of flips required.

Insight and Reflection///
/////////////////////////
Noted an improvement in the speed of problem-solving and clarity in planning. Early mistakes led to a deeper 
 understanding of string manipulation and iterative logic.

Gained proficiency in managing string operations and logical structures, particularly in optimizing solutions for 
 problems requiring manipulation of sequential data.

Plans to further refine skills in algorithm optimization and handling edge cases, which are crucial for ensuring the 
 robustness and efficiency of solutions.


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///NiceOrUgly problem///
////////////////////////

Problem Understanding and Initial Strategy///
/////////////////////////////////////////////

word is 'ugly' if it has 3 vowels in a row, or 5 constants in a row.
a string is nice if it is not ugly
return 42 if a string can be ugly or nice

initially to satisfy 'ugly' i will have a counter for vowels and constants
so if there is a vowel, vowel++
if theres a constant, constanant++
whenever vowel or constant is incremented, the other will be set to 0 as the patters is interupted

if vowel = 3 or constant = 5, return "ugly"

return nice if else,

given a string with no '?'

for loop through each element checking for vowels and constanants.
when for loop is finsihed,
check if ugly bool is true, else
return nice


given a string with '?'

create two string copies,

string sVow
string sCon
bool question mark;

for loop through and replace the '?' with vowel or constanant

if question mark bool is true,

for loops checking each string will be run, 
if not met,
the usual code is run.

if question mark is true
run code,
have nice bool

at the end have a if statement to check for both ugly and nice bool,
and return 42 if true.
