Reppity Problem::

We are given a string of with up to 50 inputs,

FIND LENGTH OF LONGEST SUBSTRING that appears atleast twice.

so given a string
detirmine length of string

given length, start at index 0 and itterate through array,

take first index value, then ittereate through array with a nested loop to see if it
appears atleast twice,

    if it appears twice, take next index value and add to the substring 
    (so substring consists of string[0] and string[1] now) and ittereate through again 
    to see if it appears atleast twice.

    if it doesnt appear atleast twice, move to next value

    if it appears 0 and index is not 0, reset substring to new index value and start again


so given a substring "ABCDEXXXYYYZZZABCDEZZZYYYXXX"

it should take A, loop through and see how many times A repeats,
it appears atleast twice, yes? count++;
Substring doesnt reset to empty.
if it doesnt appear atleast twice, substring is empty.


Take substring + next index value (AB)
does it appear atleast twice?
    yes, count++ and substring doesnt empty,
if it doesn't substring is empty,


After completing the problem and researching on the geeks for geeks website I found my inital approach was wrong.

I ended up doing this instead.

Outer Loop (len)

This loop iterates over possible lengths of the repeating substring from 1 to n / 2.
    A substring must appear at least twice to be considered a repeating pattern. 
    If the length of the substring is more than half of the total string length, 
    it can't appear twice without overlapping


First Inner Loop (i)

For each len, the first inner loop iterates over starting positions i from 0 to n - 2 * len.
This ensures that there is enough room left for at least two non-overlapping occurrences 
of a substring of length len.

Second Inner Loop (j)

For each i, this loop checks for another occurrence of the substring starting from i by looking from j = i + len up to n - len.
It compares the substring of length len starting at i with all possible substrings of length len that could follow it.

This was a very difficult question and pushed my understand.

ChangingString Porblem::

this one i will solve through divide and conquor method

Given arrays A={aaa} and B={baz} and K = 1;

find largest distance between to indexes of A and B
    if K == 0 return size
    else
    change index value to that of its partner
        e.g.B[2] = A[2];
    recursive function call
    start again

The logic was completely wrong here, i could do any recursive calls 
as a proper base case couldnt be implemented without a heavy helper functions
so I scrapped that idea.

I first created a vector of differences between the two arrays

Then create a while loop - While(K > 0)
    this loop held the logic to minimize the total distance by making K changes

I then found the element with the largest difference and its index
    If this number was 0 and K was > 0, K changes was returned as this was typically the 
    A="aa", B="aa" and K = 2 case.

if statement to ensure the index is a valid position and maximum distance is non 0
    largest distance is set to 0 as it is considered changed.

K--;

when while loop ends

calculation for total distance is made and returned.

EggCarton problem::

we need to find the number of cartons to achieve the exact amount of eggs needed.
There a two types of cartons, those that hold 6, and those that hold 8.
n is exact number of eggs needed


therefore, it could be:
    n / 6,
    n / 8
    or 8+6 = n, or 8+6+6 = n;

the first two are simple to implement with if statements.

now for the combination were are looking for the smallest number of cartons,

as it could be 8+6+6 or 8+8+6, we need two loops checking this.

first starting with 8,

a for loop that takes the product of 8 and the loop itteration,
then in a nested for loop loop through and add 6,
if the sum is equal to n, return the outer loop itterations by the inner loop itterations;

now if this doesnt produce a result, we move to the loop for the carton with 6 eggs.

and if this doesn't we go to the if (n % 8 == 0) and (n % 6 == 0) statments.
Going from highest to lowest to ensure lowest possible cartions.

and finally if that isnt true, return -1 for impossible.
    



